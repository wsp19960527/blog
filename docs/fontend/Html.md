---
title: html
date: 2024/03/02
tags:
  - html
categories:
  - html
  - fontend
---

### DOCTYPE 的作用是什么？

```
IE5.5 引入了文档模式的概念，而这个概念是通过使用文档类型（DOCTYPE）切换实现的。

<!DOCTYPE>声明位于 HTML 文档中的第一行，处于 <html> 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。

DOCTYPE 不存在或格式不正确会导致文档以兼容模式呈现。
```

### 标准模式与兼容模式各有什么区别？

标准模式的渲染方式和 JS 引擎的解析方式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示
，模拟老式浏览器的行为以防止站点无法工作。

### HTML5 为什么只需要写 `<!DOCTYPE HTML>`，而不需要引入 DTD？

HTML5 不基于 SGML，因此不需要对 DTD 进行引用，但是需要 DOCTYPE 来规范浏览器的行为（让浏览器按照它们应该的方式来运
行）。

而 HTML4.01 基于 SGML ，所以需要对 DTD 进行引用，才能告知浏览器文档所使用的文档类型。

### SGML 、 HTML 、XML 和 XHTML 的区别？

SGML（Standard Generalized Markup language）是标准通用置标语言，是一种定义电子文档结构和描述其内容的国际标准语言，是所有电子文档标记语言的起源。

HTML（HyperText Markup Language）是超文本标记语言，主要是用于规定怎么显示网页。

XML（Extensible Markup Language）是可扩展标记语言是未来网页语言的发展方向，XML 和 HTML 的最大区别就在于 XML 的标签是可以自己创建的，数量无限多，
而 HTML 的标签都是固定的而且数量有限。

XHTML（Extensible Hypertext Markup Language）也是现在基本上所有网页都在用的标记语言，他其实和 HTML 没什么本质的区别，标签都一样，用法也都一样，就是比 HTML
更严格，比如标签必须都用小写，标签都必须有闭合标签等。

### DTD 介绍

DTD（ Document Type Definition 文档类型定义）是一组机器可读的规则，它们定义 XML 或 HTML 的特定版本中所有允许元
素及它们的属性和层次关系的定义。在解析网页时，浏览器将使用这些规则检查页面的有效性并且采取相应的措施。

DTD 是对 HTML 文档的声明，还会影响浏览器的渲染模式（工作模式）。

### 行内元素定义

HTML4 中，元素被分成两大类: inline （内联元素）与 block（块级元素）。一个行内元素只占据它对应标签的边框所包含的空间。

常见的行内元素有 a b span img strong sub sup button input label select textarea

### 块级元素定义

块级元素占据其父元素（容器）的整个宽度，因此创建了一个“块”。

常见的块级元素有 div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p

### 行内元素与块级元素的区别？

HTML4 中，元素被分成两大类：inline （内联元素）与 block （块级元素）。

1.  格式上，默认情况下，行内元素不会以新行开始，而块级元素会新起一行。
2.  内容上，默认情况下，行内元素只能包含文本和其他行内元素。而块级元素可以包含行内元素和其他块级元素。
3.  行内元素与块级元素属性的不同，主要是盒模型属性上：行内元素设置 width 无效，height 无效（可以设置 line-hei
    ght），设置 margin 和 padding 的上下不会对其他元素产生影响。

### HTML5 元素的分类

HTML4 中，元素被分成两大类:

- inline（内联元素）
- block（块级元素）。
  ::: tip
  但在实际的开发过程中，因为页面表现的需要，前端工程师经常把 inline 元素的 display 值设定为 block （比如 a 标签），也经常把 block 元素的 display 值设定为
  inline 之后更是出现了 inline-block 这一对外呈现 inline 对内呈现 block 的属性。因此，简单地把 HTML 元素划分为
  inline 与 block 已经不再符合实际需求。
  :::

HTML5 中，元素主要分为 7 类：

- Metadata（元数据）：这些元素用于设置文档的元数据，比如文档的标题、字符集、样式表链接等。
- Flow（流内容）：这是最常见的元素类型，用于构建网页的主要内容，包括文本、图像、表单等。
- Sectioning（分区）：这些元素用于创建文档的结构化区域，比如文章、侧边栏、页眉、页脚等。
- Heading（标题）：这些元素用于标记不同级别的标题，从 h1 到 h6。
- Phrasing（短语）：这些元素用于标记文本的短语或内联元素，比如强调、超链接、图片等。
- Embedded（嵌入）：这些元素用于嵌入外部资源，比如音频、视频、图像、应用程序等。
- Interactive（交互）：这些元素用于创建与用户交互的元素，比如超链接、按钮、表单元素等。

### 空元素定义

标签内没有内容的 HTML 标签被称为空元素。空元素是在开始标签中关闭的。

常见的空元素有：br hr img input link meta

### link 标签定义

link 标签定义文档与外部资源的关系。

link 元素是空元素，它仅包含属性。 此元素只能存在于 head 部分，不过它可出现任何次数。

link 标签中的 rel 属性定义了当前文档与被链接文档之间的关系。常见的 rel 属性取值包括：

- stylesheet：指定被链接资源是一个样式表。
- icon：指定被链接资源是一个图标。
- preconnect：指定建立预连接的资源。
- dns-prefetch：指定进行 DNS 预取的资源。
- alternate：指定当前文档是被链接资源的替代版本。
-

### 页面导入样式时，使用 link 和 @import 有什么区别？

1. 从属关系区别。 @import 是 CSS 提供的语法规则，只有导入样式表的作用；link 是 HTML 提供的标签，不仅可以加
   载 CSS 文件，还可以定义 RSS、rel 连接属性、引入网站图标等。
2. 加载顺序区别。加载页面时，link 标签引入的 CSS 被同时加载；@import 引入的 CSS 将在页面加载完毕后被加载。
3. 兼容性区别。@import 是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link 标签作为 HTML 元素，不存在兼容
   性问题。
4. DOM 可控性区别。可以通过 JS 操作 DOM ，插入 link 标签来改变样式；由于 DOM 方法是基于文档的，无法使用 @import 的方式插入样式。

### 你对浏览器的理解？

浏览器是一种用于访问和浏览互联网的软件应用程序。它允许用户输入网址，然后从互联网上获取并呈现网页内容。浏览器能够解释 HTML、CSS 和 JavaScript 等网页技术，以及支持各种插件和扩展，比如广告拦截器、密码管理器和开发人员工具。常见的浏览器包括 Google Chrome、Mozilla Firefox、Microsoft Edge、Safari 和 Opera。浏览器在不同的操作系统和设备上都有相应的版本，从桌面电脑到移动设备都可以使用浏览器来访问互联网。

简单来说浏览器可以分为两部分，shell 和 内核。

其中 shell 的种类相对比较多，内核则比较少。

shell 是指浏览器的外壳：例如菜单，工具栏等。主要是提供给用户界面操作，
参数设置等等。它是调用内核来实现各种功能的。

内核才是浏览器的核心。内核是基于标记语言显示内容的程序或模块。也有一些
浏览器并不区分外壳和内核。从 Mozilla 将 Gecko 独立出来后，才有了外壳和内核的明确划分。

### 常见的浏览器内核比较

- Trident：这种浏览器内核是 IE 浏览器用的内核，因为在早期 IE 占有大量的市场份额，所以这种内核比较流行，以前有很多网页也是根据这个内核的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好。但是由于 IE 的高市场占有率，微软也很长时间没有更新 Trident 内核，就导致了 Trident 内核和 W3C 标准脱节。还有就是 Trident 内核的大量 Bug 等安全问题没有得到解决，加上一些专家学者公开自己认为 IE 浏览器不安全的观点，使很多用户开始转向其他浏览器。

- Gecko：这是 Firefox 和 Flock 所采用的内核，这个内核的优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。

- Presto：Opera 曾经采用的就是 Presto 内核，Presto 内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的天生优势，在处理 JS 脚本等脚本语言时，会比其他的内核快 3 倍左右，缺点就是为了达到很快的速度而丢掉了一部分网页兼容性。

- Webkit：Webkit 是 Safari 采用的内核，它的优点就是网页浏览速度较快，虽然不及 Presto 但是也胜于 Gecko 和 Trident，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。WebKit 前身是 KDE 小组的 KHTML 引擎，可以说 WebKit 是 KHTML 的一个开源的分支。

- Blink：谷歌在 Chromium Blog 上发表博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。其实 Blink 引擎就是 Webkit 的一个分支，就像 webkit 是 KHTML 的分支一样。Blink 引擎现在是谷歌公司与 Opera Software 共同研发，上面提到过的，Opera 弃用了自己的 Presto 内核，加入 Google 阵营，跟随谷歌一起研发 Blink。

### 常见浏览器所用内核

```
 （1） IE 浏览器内核：Trident 内核，也是俗称的 IE 内核；

 （2） Chrome 浏览器内核：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，现在是 Blink内核；

 （3） Firefox 浏览器内核：Gecko 内核，俗称 Firefox 内核；

 （4） Safari 浏览器内核：Webkit 内核；

 （5） Opera 浏览器内核：最初是自己的 Presto 内核，后来加入谷歌大军，从 Webkit 又到了 Blink 内核；

 （6） 360浏览器、猎豹浏览器内核：IE + Chrome 双内核；

 （7） 搜狗、遨游、QQ 浏览器内核：Trident（兼容模式）+ Webkit（高速模式）；

 （8） 百度浏览器、世界之窗内核：IE 内核；

 （9） 2345浏览器内核：好像以前是 IE 内核，现在也是 IE + Chrome 双内核了；

 （10）UC 浏览器内核：这个众口不一，UC 说是他们自己研发的 U3 内核，但好像还是基于 Webkit 和 Trident ，还有说
      是基于火狐内核。
```

### 浏览器的渲染原理？

1. 构建 DOM 树：浏览器首先将接收到的 HTML 文档解析成 DOM（文档对象模型）树，这是表示网页内容的树形结构。
2. 构建 CSSOM 树：同时，浏览器也会解析 CSS 文件并构建 CSSOM（CSS 对象模型）树，这是表示样式信息的树形结构。
3. 合并 DOM 树和 CSSOM 树：浏览器将 DOM 树和 CSSOM 树合并成一个渲染树（Render Tree），其中包含了所有需要显示的节点以及其样式信息。
4. 布局：浏览器根据渲染树计算每个节点在屏幕上的确切位置和大小，这个过程称为布局（或回流）。
5. 绘制：最后，浏览器使用计算好的布局信息将每个节点绘制到屏幕上，形成最终的网页呈现效果。

值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的
html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。

详细资料可以参考：
[《浏览器渲染原理》](https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc7207f265da613c09425d)
[《浏览器的渲染原理简介》](https://coolshell.cn/articles/9666.html)
[《前端必读：浏览器内部工作原理》](https://kb.cnblogs.com/page/129756/)
[《深入浅出浏览器渲染原理》](https://blog.fundebug.com/2019/01/03/understand-browser-rendering/)

### 渲染过程中遇到 JS 文件怎么处理？

1. 下载和解析：浏览器会开始下载 JavaScript 文件，并在下载完成后对其进行解析。解析过程将生成抽象语法树（AST）和执行上下文。
2. 执行：一旦解析完成，浏览器会执行 JavaScript 代码。这可能会引起 DOM 树和 CSSOM 树的改变，从而触发重新计算渲染树、布局和绘制，这个过程称为重排和重绘。
3. 阻塞渲染：默认情况下，浏览器会在解析和执行 JavaScript 文件时阻塞渲染，因为 JavaScript 可能会修改 DOM 树和样式信息，导致渲染结果需要重新计算。为了避免出现不一致的渲染效果，浏览器会等待 JavaScript 文件执行完成后再继续渲染
   ::: tip
   也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的
   原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。来改变 JavaScript 文件的加载行为，以便更好地控制渲染过程中 JavaScript 的处理方式。
   :::

### async 和 defer 的作用是什么？有什么区别？

async 和 defer 都是用于控制浏览器加载和执行 JavaScript 文件的属性。

- 脚本没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。
- 带有 defer 属性的 script 标签告诉浏览器立即下载 JavaScript 文件，但是在文档解析完成后 DOMContentLoaded 事件触发前执行。多个带有 defer 属性的脚本文件按照它们在文档中出现的顺序依次执行
- 当浏览器遇到带有 async 属性的 script 标签时，它会异步下载该 JavaScript 文件，并在下载完成后立即执行，执行时不会阻塞文档的解析和其他资源的加载。
  多个带有 async 属性的脚本文件的执行顺序不确定，取决于下载完成的顺序。

详细资料可以参考：
[《defer 和 async 的区别》](https://segmentfault.com/q/1010000000640869)

### 什么是文档的预解析？

文档的预解析是浏览器在解析 HTML 文档时进行的一种优化步骤。它主要包括两个方面的工作：自己只解析外部资源的引用，比如外部脚本、样式表及图片。

1. 移除不合法的标记：文档预解析会移除一些不合法的标记，比如 html、body 和 head 等。这样可以快速构建 DOM 树，而不必等到整个文档都解析完毕。
2. 预加载资源：浏览器会识别并预加载一些外部资源，比如 CSS 和 JavaScript 文件。这样可以提前开始下载这些资源，以便在文档解析完毕后立即执行。

文档的预解析是浏览器为了提高页面加载性能而采取的一种优化策略。通过在解析 HTML 文档的过程中提前处理部分内容，可以加快页面的加载速度和渲染过程。

### CSS 如何阻塞文档解析？

CSS 可以阻塞文档解析的主要原因是：CSS 文件的下载和解析可能会影响页面渲染，因此浏览器会在解析文档时等待 CSS 文件的处理。

具体来说，当浏览器遇到外部 CSS 文件（通过 link 标签引入）或包含大量样式的 style 标签时，会出现以下情况：

1. 下载阻塞：浏览器在解析 HTML 文档时会发起对外部 CSS 文件的下载请求。如果 CSS 文件较大或服务器响应较慢，这可能会导致文档解析过程被阻塞，直到 CSS 文件下载完成。
2. 解析阻塞：一旦 CSS 文件下载完成，浏览器需要解析 CSS 文件并构建 CSSOM 树。这个过程也可能会消耗一定的时间，尤其是在处理大型样式表时。

在以上两种情况下，文档解析过程会受到阻碍，因为浏览器希望在构建渲染树之前获得完整的 DOM 树和 CSSOM 树。因此，CSS 文件的下载和解析可能会对文档解析和渲染产生阻塞效应。

### 渲染页面时常见哪些不良现象？

```
 FOUC：主要指的是样式闪烁的问题，由于浏览器渲染机制（比如firefox），在 CSS 加载之前，先呈现了 HTML，就会导致展示
       出无样式内容，然后样式突然呈现的现象。会出现这个问题的原因主要是 CSS 加载时间过长，或者 CSS 被放在了文档底
       部。

 白屏：有些浏览器渲染机制（比如chrome）要先构建 DOM 树和 CSSOM 树，构建完成后再进行渲染，如果 CSS 部分放在 HTML
      尾部，由于 CSS 未加载完成，浏览器迟迟未渲染，从而导致白屏；也可能是把 JS 文件放在头部，脚本的加载会阻塞后面
      文档内容的解析，从而页面迟迟未渲染出来，出现白屏问题。
```

详细资料可以参考：
[《前端魔法堂：解秘 FOUC》](https://juejin.im/entry/58f867045c497d0058e2ff3a)
[《白屏问题和 FOUC》](https://www.jianshu.com/p/6617efa874b0)

### 如何优化关键渲染路径？

为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：

1.  关键资源的数量。
2.  关键路径长度。
3.  关键字节的数量。

关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。

同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，
并且资源越大，下载所需的往返次数就越多。

最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。

优化关键渲染路径的常规步骤如下：

1. 减少关键资源的数量和大小：通过压缩和合并 CSS、JavaScript 文件，以及优化图片等方式来减少关键资源的数量和大小，从而加快它们的下载和解析速度。
2. 使用异步加载：将不影响关键渲染路径的资源（如非关键 CSS 和 JavaScript）采用异步加载的方式，可以减少对关键资源加载的阻塞。
3. 延迟加载非关键资源：将非关键资源（如下方的图片、视频等）的加载延迟到关键渲染路径完成后，可以提高页面的初次渲染速度。
4. 内联关键 CSS 和 JavaScript：将关键的 CSS 和 JavaScript 内联到 HTML 中，可以避免阻塞渲染的问题，尤其是在首屏加载时。
5. 优化关键渲染路径中的 CSS 和 JavaScript：通过减少 CSS 选择器的复杂度、移除不必要的 JavaScript 执行、避免同步 AJAX 请求等方式来优化关键渲染路径中的 CSS 和 JavaScript。

### 什么是重绘和回流？

重绘（Repaint）和回流（Reflow）是与页面渲染相关的两个重要概念。

- 重绘（Repaint）： 重绘指的是当元素样式改变，但不影响其几何属性（比如颜色、背景色等），浏览器会根据新的样式重新绘制元素，但不会影响整个文档的布局。

- 回流（Reflow）： 回流指的是当元素的尺寸、结构或布局发生变化，导致浏览器重新计算文档中元素的几何属性和页面布局，这个过程称为回流。回流是比重绘更昂贵的操作，因为它会影响整个文档的布局。

区别：

- 重绘不影响文档的布局，只需要更新受影响的元素的样式；
- 回流会影响文档的布局，需要重新计算和渲染整个文档的部分或全部内容。

在前端开发中，需要尽量减少重绘和回流的次数，以提高页面性能。可以通过合并多次对 DOM 的修改、使用 CSS3 动画代替 JavaScript 操作样式、避免频繁访问 offsetTop 和 offsetLeft 等方式来减少重绘和回流的发生。

常见引起回流属性和方法：

任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。

1. 添加或者删除可见的 DOM 元素；
2. 元素尺寸改变——边距、填充、边框、宽度和高度
3. 内容变化，比如用户在 input 框中输入文字
4. 浏览器窗口尺寸改变——resize 事件发生时
5. 计算 offsetWidth 和 offsetHeight 属性
6. 设置 style 属性的值
7. 当你修改网页的默认字体时。

回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。

常见引起重绘属性和方法：

![常见引起回流属性和方法](https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-14.png)

常见引起回流属性和方法：

![常见引起重绘属性和方法](https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-13.png)

### 如何减少回流？

1.  使用 transform 替代 top
2.  使用 classList 属性：避免直接操作元素的样式，而是使用 classList 属性来添加、移除或切换类名。这样可以避免频繁修改样式而导致的多次回流。
3.  离线操作：可以将需要多次操作的 DOM 元素脱离文档流，进行操作后再放回文档流。这样可以减少回流的发生。
4.  批量修改样式：通过修改元素的 style 属性，而不是直接修改元素的样式，可以减少回流的发生。另外，可以将多次对同一元素的样式修改合并成一次操作。
5.  使用文档片段：如果需要多次向文档中添加 DOM 元素，可以先创建一个文档片段，将新元素添加到文档片段中，最后一次性将文档片段添加到文档中。这样可以减少回流次数。
6.  避免强制同步布局属性：避免频繁访问和修改导致强制同步布局的属性，比如 offsetTop、offsetLeft、clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle 等。

### 为什么操作 DOM 慢？

1. 回流和重绘：对 DOM 的操作可能引起回流和重绘，特别是对文档结构和布局进行修改，会触发回流，而对元素样式的修改会引起重绘。回流和重绘是耗时的操作，会影响页面的性能。
2. 频繁的 DOM 访问和操作：频繁地访问和修改 DOM 元素、属性和样式，会导致性能下降。尤其是在循环中频繁进行 DOM 操作会更加明显。
3. DOM 结构复杂：当页面中包含大量的 DOM 元素时，对 DOM 进行操作会变得更加耗时。特别是在处理嵌套深层次的 DOM 结构时，会增加操作的复杂度和耗时。
4. 网络延迟：如果操作需要涉及网络请求，比如从服务器获取数据后操作 DOM，网络延迟也会导致 DOM 操作变慢。
5. 使用非优化的选择器：使用复杂或低效的 CSS 选择器，会导致查询元素的性能下降。

### DOMContentLoaded 事件和 Load 事件的区别？

DOMContentLoaded 事件和 load 事件是两个与页面加载和渲染相关的事件，它们之间有以下区别：

1. 触发时机:
   - DOMContentLoaded 事件：当初始的 HTML 文档被完全加载和解析完成之后，不需要等待样式表、图片和子框架的加载完成，就会触发 DOMContentLoaded 事件。
   - load 事件：当整个页面（包括样式表、图片、子框架等）都完全加载完成后，就会触发 load 事件。
2. 执行顺序:
   - DOMContentLoaded 事件：在所有资源完全加载之前触发，因此它的执行顺序早于 load 事件。
   - load 事件：在所有资源加载完成后触发，包括图片、样式表、脚本等。
3. 适用场景:
   - DOMContentLoaded 事件：适合执行初始化页面的操作，比如绑定事件监听器、修改 DOM 等，因为它可以在不等待所有资源加载完成的情况下执行。
   - load 事件：适合执行需要等待所有资源加载完成后才能执行的操作，比如获取图片的尺寸、计算页面的总体积等。

总之，DOMContentLoaded 事件用于指示初始 HTML 文档已完全加载和解析，而 load 事件用于指示整个页面（包括样式表、图片等）都已经加载完成。

### HTML5 有哪些新特性、移除了那些元素？

HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。

1.  新增的有：

    - 绘画 canvas;
    - 用于媒介回放的 video 和 audio 元素;
    - 本地离线存储
      - localStorage 长期存储数据，浏览器关闭后数据不丢失;
      - sessionStorage 的数据在浏览器关闭后自动删除;
    - 语意化更好的内容元素: article、footer、header、nav、section;
    - 表单控件: calendar、date、time、email、url、search;
    - 新的技术: webworker, websocket;
    - 新的文档属性: document.visibilityState

2.  移除的元素有：
    - 纯表现的元素：basefont，big，center，font, s，strike，tt，u;
    - 对可用性产生负面影响的元素：frame，frameset，noframes；

### 如何处理 HTML5 新标签的浏览器兼容问题？

1. 使用 HTML5 Shiv（又称 HTML5 Shim）：通过在页面中引入 HTML5 Shiv（如`<script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js"></script>`），可以让旧版本的 IE 浏览器正确识别 HTML5 新标签。这样就可以在旧版本的 IE 中使用新标签，而不会出现样式丢失或布局错乱的问题。
2. 手动创建新标签的样式：在 CSS 中手动创建新标签的样式，比如`<header>、<footer>、<article>`等，以便在不支持这些标签的浏览器中正确显示样式。
3. 利用 JavaScript 创建元素：在不支持 HTML5 新标签的浏览器中，可以通过 JavaScript 动态创建这些标签，然后将它们添加到文档中。这样可以让不支持 HTML5 新标签的浏览器正确解析和显示这些标签。
4. 使用 CSS Reset：使用 CSS Reset 库（如 Normalize.css）或 CSS 框架（如 Bootstrap）来统一和重置不同浏览器的默认样式，以便更好地处理浏览器兼容性问题。
5. 逐步退化：在设计和开发页面时，可以采用逐步退化的策略，先确保页面在老版本的浏览器中正常显示和操作，然后再逐步添加对 HTML5 新特性的支持。

通过以上方法，可以有效地处理 HTML5 新标签的浏览器兼容性问题，确保页面在不同浏览器中都能正确显示和操作。

### 简述一下你对 HTML 语义化的理解？

- 结构清晰：使用恰当的标签（如`<header>、<footer>、<nav>、<article>`等）来描述页面的结构，使得整个文档的结构更加清晰和易于理解。
- 内容语义明确：使用恰当的标签和属性来描述文档的内容，使得内容的语义性更加明确，不仅便于开发者理解和维护，也使得搜索引擎更好地理解页面的内容。
- 无障碍性：语义化的 HTML 有助于提高页面的无障碍性，使得屏幕阅读器等辅助技术更好地解释和呈现页面内容。
- SEO 优化：语义化的 HTML 有助于提高页面的搜索引擎优化（SEO），因为搜索引擎更容易理解页面的内容结构和主题。

### b 与 strong 的区别和 i 与 em 的区别？

`<b>`和`<strong>`以及`<i>`和`<em>`都是 HTML 中的文本格式化标签，它们之间的区别在于语义的不同：

- `<b>`是表示粗体文本的标签，它的作用是使文本以粗体显示，但并不提供额外的语义信息。因此，`<b>`标签更多地被用于纯粗体显示的场景，而不是强调某段文本的重要性或语义。
- `<strong>`是表示重要文本的标签，它的作用是对文本进行强调，强调的程度可以是粗体显示，也可以是其他形式的突出显示。同时，`<strong>`标签也具有语义上的重要性，用于标记文档中重要的、需要突出的部分。

因此，虽然在视觉上`<b>`和`<strong>`都可以让文本以粗体显示，但是语义上`<strong>`更适合用于强调重要性的文本。

- `<i>`是表示斜体文本的标签，它的作用是使文本以斜体显示，但同样并不提供额外的语义信息。因此，`<i>`标签更多地被用于纯斜体显示的场景，而不是强调某段文本的重要性或语义。
- `<em>`是表示强调文本的标签，它的作用是对文本进行强调，强调的程度可以是斜体显示，也可以是其他形式的突出显示。同时，`<em>`标签也具有语义上的重要性，用于标记文档中需要强调的部分。

因此，虽然在视觉上`<i>`和`<em>`都可以让文本以斜体显示，但是语义上`<em>`更适合用于强调的文本。

### 前端需要注意哪些 SEO ？

```
 （1）合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超
     过2次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不
     同页面 description 有所不同；keywords 列举出重要关键词即可。

 （2）语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页。

 （3）重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容肯定被
     抓取。

 （4）重要内容不要用 js 输出：爬虫不会执行 js 获取内容

 （5）少用 iframe：搜索引擎不会抓取 iframe 中的内容

 （6）非装饰性图片必须加 alt

 （7）提高网站速度：网站速度是搜索引擎排序的一个重要指标
```

前端在优化网页以提高搜索引擎优化（SEO）时，需要注意以下几个方面：

- 语义化的 HTML：使用恰当的 HTML 标签来描述文档的结构和内容，以便让搜索引擎更好地理解页面的信息。
- 页面加载速度优化：确保网页的加载速度尽可能快，可以通过压缩 CSS 和 JavaScript、使用图片懒加载、减少 HTTP 请求等方式来优化页面加载速度。
- 响应式设计：确保网站在不同设备上有良好的显示效果，包括桌面电脑、平板和手机等，以提高用户体验。
- 良好的 URL 结构：使用简洁且描述性的 URL 结构，包括关键词和描述性的路径，以便搜索引擎更好地理解页面的内容。
- 合理的标签使用：包括标题标签`<title>`、描述标签`<meta name="description">`和关键词标签`<meta name="keywords">`等，以提高页面在搜索引擎中的排名。
- 图片优化：使用描述性的文件名和 ALT 标签来优化图片，以便搜索引擎能够理解图片的内容。
- 合理的内部链接：通过合理的内部链接结构，让搜索引擎更好地理解网站的结构和内容。
- 合理的外部链接：通过合理的外部链接策略，包括获取高质量的外部链接，来提高网站在搜索引擎中的排名。

通过注意以上 SEO 方面的内容，前端可以帮助网站更好地被搜索引擎理解和索引，提高网站在搜索结果中的排名，从而获得更多的有价值的流量。

### HTML5 的离线储存怎么使用，工作原理能不能解释一下？

```
 在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。

 原理：HTML5 的离线存储是基于一个新建的 .appcache 文件的缓存机制（不是存储技术），通过这个文件上的解析清单离线存储资
      源，这些资源就会像 cookie 一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面
      展示。

 如何使用：

 （1）创建一个和 html 同名的 manifest 文件，然后在页面头部像下面一样加入一个 manifest 的属性。

     <html lang="en" manifest="index.manifest">

 （2）在如下 cache.manifest 文件的编写离线存储的资源。
   	CACHE MANIFEST
   	#v0.11
   	CACHE:
   	js/app.js
   	css/style.css
   	NETWORK:
   	resourse/logo.png
   	FALLBACK:
   	/ /offline.html

     CACHE: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出
            来。

     NETWORK: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些
              资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 C
              ACHE 的优先级更高。

     FALLBACK: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下
               任何一个资源失败了，那么就去访问 offline.html 。

 （3）在离线状态时，操作 window.applicationCache 进行离线缓存的操作。


 如何更新缓存：

 （1）更新 manifest 文件
 （2）通过 javascript 操作
 （3）清除浏览器缓存

 注意事项：

 （1）浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。
 （2）如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。
 （3）引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。
 （4）FALLBACK 中的资源必须和 manifest 文件同源。
 （5）当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。
 （6）站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。
 （7）当 manifest 文件发生改变时，资源请求本身也会触发更新。

```

详细的使用可以参考：
[《HTML5 离线缓存-manifest 简介》](https://yanhaijing.com/html/2014/12/28/html5-manifest/)
[《有趣的 HTML5：离线存储》](https://segmentfault.com/a/1190000000732617)

### 浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的呢？

在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app ，那么浏览器
就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器
就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。

离线的情况下，浏览器就直接使用离线存储的资源。

### 常见的浏览器端的存储技术有哪些？

浏览器常见的存储技术有 cookie、localStorage 和 sessionStorage。

还有两种存储技术用于大规模数据存储，webSQL（已被废除）和 indexDB。

IE 支持 userData 存储数据，但是基本很少使用到，除非有很强的浏览器兼容需求。

### 请描述一下 cookies，sessionStorage 和 localStorage 的区别？

SessionStorage， LocalStorage， Cookie 这三者都可以被用来在浏览器端存储数据，而且都是字符串类型的键值对。区别
在于前两者属于 HTML5 WebStorage，创建它们的目的便于客户端存储数据。而 cookie 是网站为了标示用户身份而储存在用户
本地终端上的数据（通常经过加密）。cookie 数据始终在同源（协议、主机、端口相同）的 http 请求中携带（即使不需要），会在浏览器和服务器间来回传递。

1.  存储大小：

- cookie 数据大小不能超过 4 k 。
- sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。

2. 有期时间：

   - localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据。
   - sessionStorage 数据在页面会话结束时会被清除。页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会
     保持原来的页面会话。在新标签或窗口打开一个页面时会在顶级浏览上下文中初始化一个新的会话。
   - cookie 设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。

3. 作用域：
   - sessionStorage 只在同源的同窗口（或标签页）中共享数据，也就是只在当前会话中共享。
   - localStorage 在所有同源窗口中都是共享的。
   - cookie 在所有同源窗口中都是共享的。

### iframe 有那些缺点？

iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。

主要缺点有：

- iframe 会阻塞主页面的 onload 事件。window 的 onload 事件需要在所有 iframe 加载完毕后（包含里面的元素）才会触发。在 Safari 和 Chrome 里，通过 JavaScript 动态设置 iframe 的 src 可以避免这种阻塞情况。
- 搜索引擎的检索程序无法解读这种页面，不利于网页的 SEO 。
- iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。
- 浏览器的后退按钮失效。
- 小型的移动设备无法完全显示框架。

### Label 的作用是什么？是怎么用的？

label 标签来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。

```html
<label for="Name">Number:</label> <input type="“text“" name="Name" id="Name" />
```

### HTML5 的 form 的自动完成功能是什么？

autocomplete 属性规定输入字段是否应该启用自动完成功能。默认为启用，设置为 autocomplete=off 可以关闭该功能。

自动完成允许浏览器预测对字段的输入。当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。

autocomplete 属性适用于 `<form>`，以及下面的 `<input>` 类型：text, search, url, telephone, email, password,
datepickers, range 以及 color。

### 如何实现浏览器内多个标签页之间的通信?

- 使用 WebSocket，通信的标签页连接同一个服务器，发送消息到服务器后，服务器推送消息给所有连接的客户端。
- 使用 SharedWorker （只在 chrome 浏览器实现了），两个页面共享同一个线程，通过向线程发送数据和接收数据来实现标签页之间的双向通行。
- 可以调用 localStorage、cookies 等本地存储方式，localStorge 另一个浏览上下文里被添加、修改或删除时，它都会触发一个 storage 事件，我们通过监听 storage 事件，控制它的值来进行页面信息通信；
- 如果我们能够获得对应标签页的引用，通过 postMessage 方法也是可以实现多个标签页通信的。

实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，
让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。

第一种实现的方式是使用 websocket 协议，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。
标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。

第二种是使用 ShareWorker 的方式，shareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使
用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交
换。

第三种方式是使用 localStorage 的方式，我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页
修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色。

还有一种方式是使用 postMessage 方法，如果我们能够获得对应标签页的引用，我们就可以使用 postMessage 方法，进行通信。

### webSocket 如何兼容低版本浏览器？

- 使用 Polyfill 库：可以使用现有的 Polyfill 库，如 Socket.IO、SockJS 等，它们可以在不支持 WebSocket 的浏览器上模拟 WebSocket 的功能，从而实现跨浏览器的兼容性。
- 使用长轮询（Long Polling）：在不支持 WebSocket 的浏览器上，可以通过长轮询技术来模拟实时通信。通过向服务器发送一个长时间挂起的 HTTP 请求，服务器在有新数据时返回响应，然后客户端再次发送请求。
- 使用 Flash Socket：可以通过使用 Adobe Flash 插件来实现跨浏览器的实时通信，Flash 支持 Socket 连接，并且可以在不支持 WebSocket 的浏览器上使用。
- 使用 AJAX 轮询：通过定时向服务器发送 AJAX 请求，来获取最新数据，实现一种简单的实时通信模拟。

这些方法可以在不支持 WebSocket 的低版本浏览器上实现类似 WebSocket 的功能，从而实现跨浏览器的兼容性。

### 页面可见性（Page Visibility API） 可以有哪些用途？

- 节省资源：当页面不可见时，可以暂停或减少一些耗费资源的操作，如动画、定时器、后台请求等，以节省 CPU 和网络资源。
- 优化用户体验：可以根据页面可见性来优化用户体验，例如在页面不可见时暂停视频播放、音频播放或动画效果，防止用户在不可见页面时受到干扰。
- 监控用户行为：可以根据页面可见性来监控用户行为，例如统计用户在页面可见和不可见时的停留时间，分析用户对页面的关注度和活跃度。
- 自动刷新数据：可以在页面可见时自动刷新数据，以确保用户在返回页面时能够看到最新的内容。
- 优化广告展示：可以根据页面可见性来优化广告展示策略，以提高广告的曝光和点击率。

要使用页面可见性（Page Visibility API），可以按照以下步骤：

1. 检查浏览器支持：首先检查浏览器是否支持 Page Visibility API。可以使用以下代码片段进行检查：

```js
if (document.visibilityState) {
	// 支持 Page Visibility API
} else {
	// 不支持 Page Visibility API
}
```

2. 添加事件监听器：添加页面可见性状态变化的事件监听器，以便在页面可见性状态发生变化时进行相应的处理。可以使用以下代码来添加事件监听器：

```js
document.addEventListener("visibilitychange", function () {
	if (document.visibilityState === "visible") {
		// 页面变为可见时的处理逻辑
	} else {
		// 页面变为不可见时的处理逻辑
	}
});
```

3. 根据页面可见性状态进行处理：在事件监听器中，可以根据页面可见性状态（document.visibilityState）进行相应的处理，例如暂停或恢复动画、定时器、请求等操作，或者记录用户停留时间等。

总之，页面可见性 API 可以帮助开发者根据页面的可见性状态来优化页面性能、提高用户体验、监控用户行为等，从而更好地管理和控制页面的行为。

### 如何在页面上实现一个圆形的可点击区域？

1. 纯 html 实现，使用 `<area>` 来给 `<img>` 图像标记热点区域的方式，`<map>` 标签用来定义一个客户端图像映射，`<area>`标签用来定义图像映射中的区域，area 元素永远嵌套在 map 元素内部，我们可以将 area 区域设置为圆形，从而实现可点击的圆形区域。
2. 纯 css 实现，使用 border-radius ，当 border-radius 的长度等于宽高相等的元素值的一半时，即可实现一个圆形的点击区域。
3. 纯 js 实现，判断一个点在不在圆上的简单算法，通过监听文档的点击事件，获取每次点击时鼠标的位置，判断该位置是否在我们规定的圆形区域内。

###`<img>` 的 title 和 alt 有什么区别？

title 通常当鼠标滑动到元素上的时候显示 alt 是` <img />` 的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。

### Canvas 和 SVG 有什么区别？

Canvas 是一种通过 JavaScript 来绘制 2D 图形的方法。Canvas 是逐像素来进行渲染的，因此当我们对 Canvas 进行缩放时，
会出现锯齿或者失真的情况。

SVG 是一种使用 XML 描述 2D 图形的语言。SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。我们可以为某个元素
附加 JavaScript 事件监听函数。并且 SVG 保存的是图形的绘制方法，因此当 SVG 图形缩放时并不会失真。

1. 绘图方式：
   - Canvas：基于像素的绘图方式，通过 JavaScript 绘制 2D 图形和动画，绘制的内容是一系列的像素点。
   - SVG：基于 XML 的矢量图形绘制方式，使用 XML 标签描述图形，绘制的内容是矢量图形，可以无损放大缩小。
2. 图形处理：
   - Canvas：适合绘制动态、实时的图形和动画，对图形的处理需要手动编写 JavaScript 代码。
   - SVG：适合静态或交互式的图形和图表，对图形的处理可以使用 CSS 和 JavaScript 来实现。
3. 性能：
   - Canvas：对于复杂的动态图形和动画，Canvas 通常具有更好的性能，因为绘制的是像素点，不需要保留每个图形的状态。
   - SVG：对于静态或简单的图形，SVG 通常具有更好的性能，因为它可以利用浏览器的缓存和重绘机制。
4. 交互性：
   - Canvas：相对较低的交互性，因为绘制的是像素点，需要手动处理交互逻辑。
   - SVG：具有较高的交互性，因为可以直接操作 DOM 元素，利用 JavaScript 和 CSS 来实现交互效果。

### 网页验证码是干嘛的，是为了解决什么安全问题？

- 区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水
- 有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试

### 渐进增强和优雅降级的定义

- 渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。
- 优雅降级：一开始就根据高版本浏览器构建完整的功能，然后再针对低版本浏览器进行兼容。

### attribute 和 property 的区别是什么？

- attribute 是 dom 元素在文档中作为 html 标签拥有的属性；
- property 就是 dom 元素在 js 中作为对象拥有的属性。对于 html 的标准属性来说，attribute 和 property 是同步的，是会自动更新的，但是对于自定义的属性来说，他们是不同步的。

### 对 web 标准、可用性、可访问性、可维护性的理解

- Web 标准：Web 标准是一系列由 W3C（World Wide Web Consortium）和其他组织制定的技术规范，旨在确保网页在不同浏览器和设备上的一致性表现和行为。这包括 HTML、CSS、JavaScript 等技术规范，以及相关的 API 和协议。遵循 Web 标准可以提高网页的跨平台兼容性、可维护性和可访问性。
- 可用性：可用性是指用户在使用网站或应用程序时的便利性和效率性。一个具有良好可用性的网站或应用程序应当易于学习、有效地完成任务、提供清晰的反馈和导航，以及符合用户习惯的设计和交互方式，从而提高用户满意度和使用效率。
- 可访问性：可访问性是指网站或应用程序对于残障用户的友好程度。具有良好可访问性的网站或应用程序应当考虑到残障用户的需求，采用无障碍设计和技术，使得残障用户也能够方便地获取信息和进行交互。
- 可维护性：可维护性是指网站或应用程序在开发、更新和维护过程中的易于管理和修改程度。具有良好可维护性的网站或应用程序应当采用清晰的结构和命名规范，遵循设计模式和最佳实践，以及提供文档和注释，从而降低维护成本和风险。

综合来看，Web 标准是确保网页技术和规范的统一性和稳定性，可用性是提高用户体验和效率性的关键，可访问性是促进公平获取信息和服务的重要保障，可维护性是降低开发和维护成本的重要因素。这四者共同构成了构建用户友好、稳健和可持续发展的网页和应用程序的重要基础。

### IE 各版本和 Chrome 可以并行下载多少个资源？

- IE6 2 个并发
- iE7 升级之后的 6 个并发，之后版本也是 6 个
- Firefox，chrome 也是 6 个

### Flash、Ajax 各自的优缺点，在使用中如何取舍？

Flash 和 Ajax 是用于 Web 开发的两种不同技术，它们各自有优点和缺点，而在使用中需要根据具体情况来取舍。

Flash 的优点和缺点：

- 优点：
  - 动画和多媒体表现力强，可以实现复杂的交互效果。
  - 跨浏览器兼容性好，可以在不同平台上一致地展现。
  - 提供了丰富的开发工具和库，便于开发者进行开发和调试。
- 缺点：
  - 需要安装插件，可能存在安全漏洞和性能问题。
  - 不利于搜索引擎优化，对 SEO 不友好。
  - 在移动设备上的支持不佳，不利于响应式设计和移动端开发。

Ajax 的优点和缺点：

- 优点：
  - 提供了异步数据交互，可以在不刷新整个页面的情况下更新部分内容，提升用户体验。
  - 支持前端和后端的分离开发，有利于实现单页面应用和 RESTful API。
  - 对搜索引擎友好，有利于 SEO。
- 缺点：
  - 对浏览器的兼容性要求较高，可能需要处理不同浏览器的兼容性问题。
  - 可能导致页面状态管理复杂，需要谨慎设计和开发，避免出现混乱和性能问题。
  - 对于一些复杂的交互效果和动画，实现起来可能相对复杂。

在使用中，需要根据具体的需求和场景来取舍。一般来说，可以考虑以下因素：

- 如果需要实现复杂的动画和多媒体效果，并且对兼容性要求不是特别严格，可以考虑使用 Flash。
- 如果需要实现异步数据交互、提升用户体验，并且对 SEO 友好的话，可以考虑使用 Ajax。

此外，随着 HTML5 和现代浏览器的发展，一些原本由 Flash 实现的功能已经可以通过 HTML5 和 JavaScript 实现，而 Ajax 也得到了更好的支持和扩展，因此在实际项目中可能会更多地选择 HTML5 和 Ajax 来实现相应的功能。

### 浏览器架构

- 用户界面（UI）：包括地址栏、书签栏、后退/前进按钮等用于与用户交互的部分。
- 浏览器引擎：用于处理用户界面和渲染引擎之间的交互。它负责解析 HTML 和 CSS，以及执行 JavaScript 代码。
- 渲染引擎：负责显示请求的内容。例如，当请求一个 HTML 页面时，渲染引擎会解析 HTML 和 CSS，然后将内容显示在屏幕上。
- 网络：用于网络调用，比如 HTTP 请求。它包括所有的网络调用，比如 XHR 请求或者使用 Fetch API。
- 用户界面后端：用于绘制基本的窗口小部件，如组合框和窗口。不同的浏览器使用不同的工具包，如 Windows 系统上的本机工具包。
- JavaScript 解释器：用于解释和执行 JavaScript 代码。
- 数据存储：这是持久层。浏览器需要在本地存储大量数据，如 Cookie 等。HTML5 定义了“web database”技术，这是一种完整的数据库系统，完全运行在浏览器中。
- 插件：如 Flash 插件，用于显示 Flash 内容，或者 QuickTime 插件，用于打开 QuickTime 视频等。

### 常用的 meta 标签

```
 <meta> 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。
 <meta> 标签位于文档的头部，不包含任何内容。<meta> 标签的属性定义了与文档相关联的名称/值对。

 <!DOCTYPE html>  H5标准声明，使用 HTML5 doctype，不区分大小写
 <head lang="en"> 标准的 lang 属性写法
 <meta charset="utf-8">    声明文档使用的字符编码
 <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>   优先使用 IE 最新版本和 Chrome
 <meta name="description" content="不超过150个字符"/>       页面描述
 <meta name="keywords" content=""/>      页面关键词者
 <meta name="author" content="name, email@gmail.com"/>    网页作
 <meta name="robots" content="index,follow"/>      搜索引擎抓取
 <meta name="viewport" content="initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no"> 为移动设备添加 viewport
 <meta name="apple-mobile-web-app-title" content="标题"> iOS 设备 begin
 <meta name="apple-mobile-web-app-capable" content="yes"/>  添加到主屏后的标题（iOS 6 新增）
 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏
 <meta name="apple-itunes-app" content="app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL">
 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）
 <meta name="apple-mobile-web-app-status-bar-style" content="black"/>
 <meta name="format-detection" content="telphone=no, email=no"/>  设置苹果工具栏颜色
 <meta name="renderer" content="webkit">  启用360浏览器的极速模式(webkit)
 <meta http-equiv="X-UA-Compatible" content="IE=edge">     避免IE使用兼容模式
 <meta http-equiv="Cache-Control" content="no-siteapp" />    不让百度转码
 <meta name="HandheldFriendly" content="true">     针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓
 <meta name="MobileOptimized" content="320">   微软的老式浏览器
 <meta name="screen-orientation" content="portrait">   uc强制竖屏
 <meta name="x5-orientation" content="portrait">    QQ强制竖屏
 <meta name="full-screen" content="yes">              UC强制全屏
 <meta name="x5-fullscreen" content="true">       QQ强制全屏
 <meta name="browsermode" content="application">   UC应用模式
 <meta name="x5-page-mode" content="app">    QQ应用模式
 <meta name="msapplication-tap-highlight" content="no">    windows phone 点击无高光
 设置页面不缓存
 <meta http-equiv="pragma" content="no-cache">
 <meta http-equiv="cache-control" content="no-cache">
 <meta http-equiv="expires" content="0">
```

[《Meta 标签用法大全》](http://www.cnblogs.com/qiumohanyu/p/5431859.html)

### css reset 和 normalize.css 有什么区别？

CSS Reset 和 Normalize.css 都是用于重置和规范化浏览器样式的工具，但它们有一些区别：

CSS Reset:

- CSS Reset 的目标是通过重置所有 HTML 元素的默认样式，以消除浏览器之间的差异，使得所有元素在不同浏览器中表现一致。
- CSS Reset 会重置所有元素的外边距、内边距、列表样式、文本样式等，使得开发者可以从一个标准化的基础上构建自己的样式。
- 由于 CSS Reset 会将所有元素的样式重置为一致的基础样式，因此在使用时需要谨慎，可能需要重新定义大量的样式。
- 一些常见的 CSS Reset 工具包括 Eric Meyer's Reset CSS、Normalize.css 等。

Normalize.css:

- Normalize.css 的目标是保留有用的默认样式，并纠正浏览器的 bug 和常见的不一致性，使得不同浏览器在展现上更为一致。
- 相比于完全重置所有元素的样式，Normalize.css 更加注重保留有用的默认样式，避免了在构建自己的样式时需要重新定义大量的样式。
- Normalize.css 在一些常见的不一致性和 bug 上提供了一些默认的修复，使得开发者在构建样式时更加稳定和一致。

综上所述，CSS Reset 和 Normalize.css 在目标和实现方式上有一些区别。选择使用哪一种取决于开发者对于样式重置和规范化的需求和偏好。

### 用于预格式化文本的标签是？

用于预格式化文本的标签是`<pre>`。这个标签通常用于显示计算机代码或预格式化的文本，其中空格和换行符会被保留，文本会按照原始的格式显示。这在需要展示代码示例或保持文本格式的情况下非常有用。

### DHTML 是什么？

DHTML 是动态 HTML（Dynamic HTML）的缩写，它是一种用于创建交互式和动态网页的技术。DHTML 结合了 HTML、CSS 和 JavaScript 等技术，使得网页在用户与之交互时可以动态地改变内容、样式和布局，从而提供更丰富的用户体验。

DHTML 的主要特点包括：

- 动态内容：允许网页上的内容在不需要重新加载整个页面的情况下进行动态更新和改变。
- 交互式控件：通过 JavaScript 等技术，可以创建交互式的控件和元素，如下拉菜单、动态菜单、表单验证等。
- 样式和布局：可以动态地改变和调整网页的样式和布局，实现更加灵活的设计效果。

总的来说，DHTML 是一种用于创建动态和交互式网页的技术，它结合了 HTML、CSS 和 JavaScript 等技术，为用户提供更加丰富和灵活的网页体验。

### head 标签中必不少的是？

`<head>`标签用于定义文档的头部，它是所有头部元素的容器。`<head>` 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等等。

文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。

下面这些标签可用在 head 部分：`<base>, <link>, <meta>, <script>, <style>, 以及 <title>`。

`<title> `定义文档的标题，它是 head 部分中唯一必需的元素。

### HTML5 新增的表单元素有？

- `<datalist>`：用于定义输入域的选项列表。它可以与`<input>`元素结合使用，提供一组可选的值供用户选择。
- `<output>`：用于显示计算结果。当用户提交表单时，可以使用`<output>`元素来显示计算或处理后的结果。
- `<keygen>`：用于创建公钥和私钥对的表单元素。它通常用于在表单提交时创建密钥对，用于加密和解密数据。
- `<progress>`：用于显示任务的完成进度。可以在页面上显示任务的进度条，比如文件上传的进度等。
- `<meter>`：用于显示已知范围内的标量数值。可以用来表示血压、温度等范围值。

### 在 HTML5 中，哪个方法用于获得用户的当前位置？

navigator.geolocation 对象的 getCurrentPosition()方法来获取用户的当前位置。这个方法会触发一个异步操作，向用户请求位置信息，并在位置信息可用时调用指定的回调函数。通过使用 getCurrentPosition()方法，开发者可以获取用户的经度、纬度等位置信息，从而实现基于地理位置的应用程序功能。

```js
if (navigator.geolocation) {
	navigator.geolocation.getCurrentPosition(function (position) {
		var latitude = position.coords.latitude;
		var longitude = position.coords.longitude;
		console.log("Latitude: " + latitude + " Longitude: " + longitude);
		// 在这里可以对获取到的位置信息进行处理
	});
} else {
	console.log("Geolocation is not supported by this browser.");
}
```

#### 63. 文档的不同注释方式？

```
 HTML 的注释方法 <!--注释内容-->

 CSS 的注释方法 /*注释内容*/

 JavaScript 的注释方法 /* 多行注释方式 */ //单行注释方式
```

#### 64. disabled 和 readonly 的区别？

disabled 和 readonly 是用于表单元素的属性，它们有以下区别：

- disabled:
  - 当一个表单元素被设置为 disabled 时，它会被禁用，用户无法对其进行任何操作，也不会将其值提交给服务器。
  - 被禁用的元素通常会呈灰色，以示不可用。
- readonly:

  - 当一个表单元素被设置为 readonly 时，用户可以看到该元素的值，但无法对其进行编辑或修改。
  - 该元素的值会在表单提交时被包含在表单数据中，可以被提交给服务器。

无论设置 readonly 还是 disabled，通过 js 脚本都能更改 input 的 value

### 主流浏览器内核私有属性 css 前缀？

主流浏览器内核私有属性的CSS前缀如下：

- WebKit（Chrome、Safari）：-webkit-
- Gecko（Firefox）：-moz-
- Trident（Internet Explorer）：-ms-
- Presto（Opera）：-o-

### 前端性能优化？

- 压缩和合并资源：压缩JavaScript、CSS和HTML文件，合并多个文件以减少HTTP请求次数。
- 使用CDN：将静态资源（如JavaScript库、CSS文件、图片）托管到内容分发网络（CDN）上，以提高资源加载速度。
- 优化图片：使用适当的图片格式（如WebP、JPEG 2000），压缩图片以减小文件大小，以及使用响应式图片来适应不同屏幕尺寸。
- 延迟加载：将不是立即需要的资源延迟加载，如图片懒加载、按需加载JavaScript等。
- 减少重绘和回流：避免频繁修改DOM，合理使用CSS，减少浏览器的重绘和回流。
- 使用缓存：利用浏览器缓存机制，合理设置资源的缓存策略，减少重复的资源请求。
- 异步加载：使用异步加载JavaScript，延迟执行不影响首屏渲染的任务。
- 服务端渲染：对于需要SEO的页面，使用服务端渲染来提高首屏加载速度。

[《前端性能优化之雅虎 35 条军规》](https://juejin.im/post/5b73ef38f265da281e048e51#heading-10)
[《你真的了解 gzip 吗？》](https://juejin.im/entry/58709b9a128fe1006b29cd5d)
[《前端性能优化之 gzip》](https://segmentfault.com/a/1190000012571492)

### Chrome 中的 Waterfall ？

在Chrome浏览器中，"Waterfall"通常是指开发者工具中的"Network"面板，该面板显示了网页加载过程中各个资源的加载时间线和详细信息。这个时间线以瀑布流的形式展现了每个资源的加载过程，包括DNS解析、TCP连接、SSL握手、请求发送、响应接收等。

通过查看这个"Waterfall"时间线，开发者可以分析各个资源的加载情况，找出加载时间长的资源或者网络性能瓶颈，从而优化网页加载速度。这对于前端性能优化和网站性能调优非常有帮助。

[《前端性能之 Chrome 的 Waterfall》](https://blog.csdn.net/carian_violet/article/details/84954360)
[《教你读懂网络请求的瀑布图》](https://blog.csdn.net/csdn_girl/article/details/54911632) [《前端妹子跟我抱怨她们的页面加载很慢的时候，如何在她面前优雅地装逼？》](https://www.zhihu.com/question/27085552/answer/35194131)

### 扫描二维码登录网页是什么原理，前后两个事件是如何联系的？

- 生成二维码：服务端生成一个包含唯一标识的二维码，并将该标识关联到用户的登录状态。
- 扫描二维码：用户使用手机或其他设备的摄像头扫描二维码，扫描的数据包含了唯一标识信息。
- 发送请求：设备通过扫描获取的唯一标识信息，向服务端发送授权请求。
- 验证身份：服务端接收到请求后，根据唯一标识信息验证用户的身份，并将用户的登录状态与该唯一标识关联起来。
- 建立会话：一旦用户身份验证成功，服务端会建立一个会话，并返回一个登录凭证或者令牌给设备。

前后两个事件联系：前后两个事件通过唯一标识信息进行联系。扫描二维码获取的唯一标识信息被发送到服务端，服务端根据该唯一标识信息来识别用户，并与用户的登录状态进行关联。

[《微信扫描二维码登录网页》](https://www.zhihu.com/question/20368066)

### Html 规范中为什么要求引用资源不加协议头`http`或者`https`？

HTML规范中建议不在资源引用URL中加入协议头http或https的原因是为了提高网页的兼容性和安全性。

- 提高兼容性：如果资源引用中包含了特定的协议头（如http或https），那么在不同的协议下（HTTP或HTTPS）访问网页时可能会导致某些浏览器对非安全资源的加载行为做出不同的处理，可能会引发警告或者阻止加载。因此，省略协议头可以使得资源能够更加灵活地适应网页的访问协议，提高了网页在不同环境下的兼容性。
- 增加安全性：在引用资源时省略协议头，浏览器会根据当前页面的协议（http或https）来决定资源的加载协议，这样可以避免在使用HTTPS协议的网页中加载非安全的HTTP资源，从而提高网页的安全性。

[《协议相对 URL》](https://www.ludou.org/the-protocol-relative-url.html)
[《Why you need protocol-relative URLs _now_》](https://www.tuicool.com/articles/nEjU7b)
